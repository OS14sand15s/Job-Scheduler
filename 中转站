void do_enq(struct jobinfo *newjob,struct jobcmd enqcmd)
{
	struct waitqueue *newnode,*p;
	int i=0,pid;
	char *offset,*argvec,*q;
	char **arglist;
	sigset_t zeromask;

	sigemptyset(&zeromask);

	/* 封装jobinfo数据结构 */
	newjob = (struct jobinfo *)malloc(sizeof(struct jobinfo));
	newjob->jid = allocjid();
	newjob->defpri = enqcmd.defpri;
	newjob->curpri = enqcmd.defpri;
	newjob->ownerid = enqcmd.owner;
	newjob->state = READY;
	newjob->create_time = time(NULL);
	newjob->wait_time = 0;
	newjob->run_time = 0;
	arglist = (char**)malloc(sizeof(char*)*(enqcmd.argnum+1));
	newjob->cmdarg = arglist;
	offset = enqcmd.data;
	argvec = enqcmd.data;
	while (i < enqcmd.argnum){
		if(*offset == ':'){
			*offset++ = '\0';
			q = (char*)malloc(offset - argvec);
			strcpy(q,argvec);
			arglist[i++] = q;
			argvec = offset;
		}else
			offset++;
	}

	arglist[i] = NULL;



	/*向等待队列中增加新的作业*/
	newnode = (struct waitqueue*)malloc(sizeof(struct waitqueue));
	newnode->next =NULL;
	newnode->job=newjob;

	if(headq1)//New comer should be added in headq1.
	{
		for(p=headq1;p->next != NULL; p=p->next);
		p->next =newnode;
	}else
		headq1=newnode;

	/*为作业创建进程*/
	if((pid=fork())<0)
		error_sys("enq fork failed");

	if(pid==0){
		newjob->pid =getpid();
		/*阻塞子进程,等等执行*/
		printf("raise stop\n");
		raise(SIGSTOP);


		/*复制文件描述符到标准输出*/
		dup2(globalfd,1);
		/* 执行命令 */
		if(execv(arglist[0],arglist)<0)
			printf("exec failed\n");
		exit(1);
	}else{
		newjob->pid=pid;
	}
}
//-------------------------------------------------------------
void do_deq(struct jobcmd deqcmd)
{
	int deqid,i;
	struct waitqueue *p,*prev,*select,*selectprev;
	deqid=atoi(deqcmd.data);

#ifdef DEBUG
	printf("deq jid %d\n",deqid);
#endif

	/*current jodid==deqid,终止当前作业*/
	if (current && current->job->jid ==deqid){
		printf("teminate current job\n");
		kill(current->job->pid,SIGKILL);
		for(i=0;(current->job->cmdarg)[i]!=NULL;i++){
			free((current->job->cmdarg)[i]);
			(current->job->cmdarg)[i]=NULL;
		}
		free(current->job->cmdarg);
		free(current->job);
		free(current);
		current=NULL;
	}
	else{ /* 或者在等待队列中查找deqid */
		select=NULL;
		selectprev=NULL;
		if(headq1){
			for(prev=headq1,p=headq1;p!=NULL;prev=p,p=p->next)
				if(p->job->jid==deqid){
					select=p;
					selectprev=prev;
					break;
				}
				if(select!=NULL&&select==headq1)//headq1 is the target;
				{
					headq1=headq1->next;
					select->next=NULL;//This is a good habit;
				}
				else if(select!=NULL){
					selectprev->next=select->next;
					select->next=NULL;
				}
		}
		if(select==NULL&&headq2){
			for(prev=headq2,p=headq2;p!=NULL;prev=p,p=p->next)
				if(p->job->jid==deqid){
					select=p;
					selectprev=prev;
					break;
				}
				if(select!=NULL&&select==headq2)
				{
					headq2=headq2->next;
					select->next=NULL;
				}else if(select!=NULL){
					selectprev->next=select->next;
					select->next=NULL;
				}
		}
		if(select==NULL&&headq3){
			for(prev=headq3,p=headq3;p!=NULL;prev=p,p=p->next)
				if(p->job->jid==deqid){
					select=p;
					selectprev=prev;
					break;
				}
				if(select!=NULL&&select==headq3){
					headq3=headq3->next;
					select->next=NULL;
				}else if(select!=NULL){
					selectprev->next=select->next;
					select->next=NULL;
				}
		}
		if(select){
			for(i=0;(select->job->cmdarg)[i]!=NULL;i++){
				free((select->job->cmdarg)[i]);
				(select->job->cmdarg)[i]=NULL;
			}
			free(select->job->cmdarg);
			free(select->job);
			free(select);
			select=NULL;
		}
	}
}
//----------------------------------------------------------------
void do_stat(struct jobcmd statcmd)
{
	struct waitqueue *p;
	char timebuf[BUFLEN];
	/*
	*打印所有作业的统计信息:
	*1.作业ID
	*2.进程ID
	*3.作业所有者
	*4.作业运行时间
	*5.作业等待时间
	*6.作业创建时间
	*7.作业状态
	*/

	/* 打印信息头部 */
	printf("JOBID\tPID\tOWNER\tRUNTIME\tWAITTIME\tCREATTIME\t\tSTATE\tQUEUE\n");
	if(current){
		strcpy(timebuf,ctime(&(current->job->create_time)));
		timebuf[strlen(timebuf)-1]='\0';
		printf("%d\t%d\t%d\t%d\t%d\t%s\t%s\t%s\n",
			current->job->jid,
			current->job->pid,
			current->job->ownerid,
			current->job->run_time,
			current->job->wait_time,
			timebuf,"RUNNING","CURRENT");
	}
	for(p=headq1;p!=NULL;p=p->next){
		strcpy(timebuf,ctime(&(p->job->create_time)));
		timebuf[strlen(timebuf)-1]='\0';
		printf("%d\t%d\t%d\t%d\t%d\t%s\t%s\t%s\n",
			p->job->jid,
			p->job->pid,
			p->job->ownerid,
			p->job->run_time,
			p->job->wait_time,
			timebuf,
			"READY","q1");
	}
	for(p=headq2;p!=NULL;p=p->next){
		strcpy(timebuf,ctime(&(p->job->create_time)));
		timebuf[strlen(timebuf)-1]='\0';
		printf("%d\t%d\t%d\t%d\t%d\t%s\t%s\t%s\n",
			p->job->jid,
			p->job->pid,
			p->job->ownerid,
			p->job->run_time,
			p->job->wait_time,
			timebuf,
			"READY","q2");
	}
		for(p=headq3;p!=NULL;p=p->next){
		strcpy(timebuf,ctime(&(p->job->create_time)));
		timebuf[strlen(timebuf)-1]='\0';
		printf("%d\t%d\t%d\t%d\t%d\t%s\t%s\t%s\n",
			p->job->jid,
			p->job->pid,
			p->job->ownerid,
			p->job->run_time,
			p->job->wait_time,
			timebuf,
			"READY","q3");
	}
}
//----------------------------------------------UPDATEALL
void updateall()
{
	struct waitqueue *p,*p1,*p2,*p3,*pre;
	/* 更新作业运行时间 */
	if(current!=NULL)
		current->job->run_time += 1; /* 加1代表1000ms */
	/* 更新作业等待时间及优先级 */
	for(p=headq1;p!=NULL;p=p->next){//priority=2
		p->job->wait_time+=1000;
	}
	for(p=headq2,pre=headq2;p!=NULL;){//priority=1
		p->job->wait_time+=1000;
		if(p->job->wait_time>=10000){
			p->job->curpri=2;
			p->job->wait_time=0;
			if(p==headq2){
				headq2=headq2->next;
				p->next=NULL;
				//Find the p1
				if(headq1==NULL){
					headq1=p;
				}
				else
				{
					for(p1=headq1;p1->next!=NULL;p1=p1->next);
						p1->next=p;
				}
				p=head2;
				pre=head2;//A new beginning;
			}
			else{
				p2=p;
				pre->next=p->next;
				p2->next=NULL;
				if(headq1==NULL){
					headq1=p2;
				}else
				{
					for(p1=headq1;p1->next!=NULL;p1=p1->next);
						p1->next=p2;
				}
				p=p->next;//pre do not be changed;
			}
		}
		else{
			pre=p;
			p=p->next;
		}
	}
	for(p=headq3,pre=headq3;p!=NULL;)
	{//priority=0;
		p->job->wait_time+=1000;
		if(p-job->wait_time>=10000)
		{
			p->job->curpri=1;
			p->job->wait_time=0;
			if(headq3==p)
			{
				headq3=headq3->next;
				p->next=NULL;
				//Find the end of q2;
				if(headq2==NULL)
				{
					headq2=p;
				}
				else
				{
					for(p2=headq2;p2->next!=NULL;p2=p2->next);
						p2->next=p;
				}
				p=headq3;
				pre=headq3;
			}
			else
			{
			p3=p;
			pre->next=p->next;
			p3->next=NULL;
			if(headq2==NULL)
			{
				headq2=p3;
			}
			else
			{
				for(p2=headq2;p2->next!=NULL;p2=p2->next);
					p2->next=p3;
			}
			p=pre->next;
		}
	}
	else{
		pre=p;
		p=p->next;
	}
}

}
//--------------------------------------
struct waitqueue* jobselect()
{
	struct waitqueue *select;
	select = NULL;
	//For every queue,the mode is First Come,First Service.
	if(headq1!=NULL){
		SELECTQUEUE=1;
		select=headq1;
		headq1=headq1->next;
		select->next=NULL;
	}else if(headq2=NULL){
		SELECTQUEUE=2;
		select=headq2;
		headq2=headq2->next;
		select->next=NULL//What a good habit!
	}else if(head3!=NULL){
		SELECTQUEUE=3;
		select=headq3;
		headq3=headq3->next;
		select->next=NULL;
	}else{
		SELECTQUEUE=0;
		select=NULL;
	}
	return select;
}
