实验二

1需求说明
1.1基本要求和提高要求
基本要求：在源代码中合适的位置加入调试信息
提高要求：实现多级反馈轮转调度算法
1.2完成情况
本次实验完成了调试信息的加入和多级反馈轮转调度算法的实验，此外还修改了源码中存在的bug：一为第一个入队的作业不能立即执行，二是不断执行同一作业
2设计说明
2.1所使用的系统调用的列表
程序中使用的系统调用如fork signal waitpid等
2.2 基础要求实现说明
1-6 完成调试任务，在适当的地方加入调试打印信息
7-10本可以调用do_stat()函数，但另外写了printWaitqueue的函数进行队列中信息的打印

2.3提高要求实现说明
2.3.1 文字描述
用三个队列Q1、Q2、Q3存放相应优先级的作业（Q1最高2，Q2次高1,Q3最低0），其时间片分别为1s、2s和5s。为防止最终只有高优先级中有作业，高优先级的作业运行完相应时间片后降一级，低优先级的作业在等待时长超过10s时升一级，升降级后作业排在应入队列的队尾，等待时间改为0。
最初的作业按照其本身定义的优先级放入相应队列，新加入的作业有以下情况：
	正在执行的是Q2或Q3的作业，优先级为1或2可以抢占执行，将之前正在执行的作业排在其所在优先级队列的队尾
	正在执行的是Q3的作业，新作业都可以抢占执行，将其排在Q1队尾等待执行
	正在执行的是Q1的作业，优先级为1的本可以抢占执行，但时间片本身为1s，所以将新作业排在Q1队尾
优先级低于当前作业，不可抢占，排在本身优先级所对应的队列队尾

2.3.2 代码实现
enq.c:
	修改了高优先级，默认优先级变为最高的2
do_enq()：
	根据优先级将新来的作业加到相应优先级队列的队尾
do_deq():
	如是当前执行的作业直接结束
	如不是则遍历三个队列，以找到要终止的作业
do_stat():
	按照队列顺序打印三个队列中的信息
updateall():
	更新三个队列中的信息
	正在运行的作业运行时间+1，其他作业的等待时间+1
	有作业等待时长超过10s将其排到上一级队列队尾（优先级升高）
jobselect():
	遍历各个队列查找下一个作业
jobswitch():
	之前无作业运行则开始
	之前作业已完成 将其删除后开始新的作业
	无新的作业 输出无作业运行
	之前作业未完成 将其放置队尾后执行新的作业
	选择的新作业优先级高于等于当前执行作业时抢占	
	高优先级的时间片结束后降级，最低优先级时间片结束后放置队尾
putBack:
	新添加的函数。最高级的作业降级到次高队列时，可能有下个作业还应该为它的情况，但由于jobswitch里面才将作业放入正确的队列，此时jobselect已经选择了其他的作业。putBack用来将已选择但被取代的作业放回原处。
实现结果按照以下情况已截图
1）当前作业与新作业相同优先级的抢占（此处用的最低优先级）
2）最高优先级作业抢占低优先级作业（执行过1秒后降级）
3）降级（Q2降级到Q3的情况Q1只出现1s不太好找(。·_·。)）
4）等待时间超过10s升级
5）最高级作业抢占运行完毕降级后，恰好为次高级队列中唯一作业
 
3收获与感想
3.1给予你帮助的人
郑若琳和陈正妍帮助我们发现了几个程序编写的问题，我们修改了她们发现的bug
3.2从实验中学到的东西
实验中我学到了这样代码量较大的程序的调试方法，在正确的地方加入打印语句将所有想知道的细节信息全部打印。
实验使我们更加深入地理解分级轮转调度的方法，在理论课程的学习方面有很大的帮助。

4组员贡献
王晓燕：创建项目，上传源代码，完成部分调试任务，帮助完成提高任务的代码部分，监督工作；
张天宇：完成部分调试任务，修改源码中的bug，帮助调试；
崔珊博：完成部分调试任务，帮助修改源码中的bug，帮助调试;
牟许东：完成部分调试任务，重新修改调试任务的输出格式，在王晓燕的帮助下完成提高任务的代码，调试整合。
